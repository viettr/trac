[{"path":"/articles/trac-classification-pipeline.html","id":"trac-classification-pipeline","dir":"Articles","previous_headings":"","what":"trac classification pipeline","title":"trac classification pipeline","text":"tutorial aims provide insight possible analysis pipeline. start phyloseq object (McMurdie Holmes 2013). phyloseq object contain least OTU/ASV counts taxonomic assignment OTU/ASV.  demonstrate use trac, use dataset (Yatsunenko et al. 2012) MLRepo. (Vangay, Hillmann, Knights 2019). given OTU labels matched greengenes 97 database (McDonald et al. 2012). OTUs appearing less 10% samples excluded bacteria included. concrete phyloseq object (malawi) contains: otu_table: contains 54 observations 5008 OTUs tax_table: contains taxonomic assignments OTUs. rownames correspond columns otu_table sam_data: contains variable interest (Vars) additional non-compositional covariates age (numeric) sex (factor)","code":"library(tidyverse) # data wrangling and visualization library(phyloseq) # microbiome data wrangling library(trac) # trac library(kableExtra) # creating tables in rmarkdown knitr::include_graphics(\"figures/trac_workflow.png\") data(\"malawi\")"},{"path":[]},{"path":"/articles/trac-classification-pipeline.html","id":"create-a-matrix-and-generate-tree","dir":"Articles","previous_headings":"Preprocessing steps for trac","what":"Create A matrix and generate tree","title":"trac classification pipeline","text":"workflow generate matrix based phyloseq object : Extract taxonomic table phyloseq object. Optional: add OTU/ASV level taxonomic table. Replace unknown taxonomic assignments different levels, example, number. prevents data unknown taxonomic assignments thrown together. Add ancestor information –> helpful reporting results Build tree tax_table_to_phylo. also helpful visualize results end. Call phylo_to_A generate matrix","code":"# 1. extract the taxonomic table from the phyloseq object tax <- malawi@tax_table@.Data  # 2. add an OTU column based on the rownames and name the column OTU tax <- cbind(tax, rownames(tax)) colnames(tax)[ncol(tax)] <- \"OTU\" # In this example is rooted in bacteria since we only consider bacteria. If one also wants to # include archea one needs to add another root node e.g. cbind(root = \"life\", tax). Need to # adjust the for loops in the next steps and add the root to the formula in step 5  # 3. Replace unknown taxonomic assignement on the corresponding level # iterate over all levels for (i in seq_len(7)) {   # add a number when the type is unknown... e.g. \"g__\"   ii <- nchar(tax[, i]) == 3   if (sum(ii) > 0)     tax[ii, i] <- paste0(tax[ii, i], 1:sum(ii)) }  # 4. add the ancestor information with :: # iterate over all levels for (i in 2:8) {   tax[, i] <- paste(tax[, i-1], tax[, i], sep = \"::\") } tax <- as.data.frame(tax, stringsAsFactors = TRUE)  # 5. form phylo object: tree1 <- tax_table_to_phylo(~Kingdom/Phylum/Class/Order/                               Family/Genus/Species/OTU,                             data = tax, collapse = TRUE)  # 6. convert this to an A matrix to be used for aggregation: A <- phylo_to_A(tree1)"},{"path":"/articles/trac-classification-pipeline.html","id":"pseudo-count-log-transformation","dir":"Articles","previous_headings":"Preprocessing steps for trac","what":"Pseudo-count + log transformation","title":"trac classification pipeline","text":"trac expects log transformed values inputs. Since log(0)log(0) undefined need add pseudo-count (e.g. 1)","code":"log_pseudo <- function(x, pseudo_count = 1) log(x + pseudo_count) z <- log_pseudo(malawi@otu_table@.Data)"},{"path":[]},{"path":"/articles/trac-classification-pipeline.html","id":"train-test-split","dir":"Articles","previous_headings":"Model fitting","what":"Train-test split","title":"trac classification pipeline","text":"First split data train-test split evaluate predictive performance end. advanced methods can used well.","code":"# extact the label y <- malawi@sam_data$Var # transform depended variable to -1 and 1 y <- (y == \"Malawi\") * 2 - 1 # set additional covarariates to data.frame, delete the label and set the binary variable # to factor --> trac will automatically transform it internally to {0, 1} additional_covariates <- data.frame(malawi@sam_data) %>%   select(-Var) %>%   mutate(sex = as.factor(sex))  # define seed for reproducibility set.seed(1) # train test split ntot <- length(y) n <- round(2/3 * ntot) tr <- sample(ntot, n) # define training and test data ytr <- y[tr] yte <- y[-tr] ztr <- z[tr, ] zte <- z[-tr, ] additional_covariates_tr <- additional_covariates[tr, ] additional_covariates_te <- additional_covariates[-tr, ]"},{"path":"/articles/trac-classification-pipeline.html","id":"fit-model-classification-with-squared-hinge-loss","dir":"Articles","previous_headings":"Model fitting","what":"Fit model: Classification with squared hinge loss","title":"trac classification pipeline","text":"fit model train data. task predict person lives Venezuela Malawi therefore binary classification task. possible specify argument method. method solve lambda path selecting optimal tuning parameter λ\\lambda crucial. path coefficient can plotted plot_trac_path. baseline can fit sparse log-contrast model OTU level well. fit another model additional non-compositional covariates comparison. possible assign different weights additional covariates. Smaller values (w_additional_covariates) force model include covariate.","code":"# fit trac with c1 fit <- trac(ztr, ytr, A = A, min_frac = 1e-1, nlam = 10, method = \"classif\") plot_trac_path(fit) fit_log_contrast <- sparse_log_contrast(Z = ztr, y = ytr, min_frac = 1e-1,                                         nlam = 10, method = \"classif\") fit_add_covariates <- trac(Z = ztr, y = ytr, A = A,                            additional_covariates = additional_covariates_tr,                            min_frac = 1e-1, nlam = 10, method = \"classif\",                            normalized = TRUE,                            w_additional_covariates = c(0.001, 0.001)) plot_trac_path(fit_add_covariates)"},{"path":"/articles/trac-classification-pipeline.html","id":"find-optimal-hyper-parameter","dir":"Articles","previous_headings":"Model fitting","what":"Find optimal hyper-parameter","title":"trac classification pipeline","text":"optimal λ\\lambda can determined cross-validation 3 models.","code":"set.seed(1) # run cross validation cvfit <- cv_trac(fit, Z = ztr, y = ytr, A = A) #> fold 1 #> fold 2 #> fold 3 #> fold 4 #> fold 5 plot_cv_trac(cvfit) set.seed(1) cvfit_log_contrast <- cv_sparse_log_contrast(fit_log_contrast, Z = ztr, y = ytr) #> fold 1 #> fold 2 #> fold 3 #> fold 4 #> fold 5 set.seed(1) cvfit_add_covariates <- cv_trac(fit_add_covariates, Z = ztr, y = ytr, A = A,                                 additional_covariates =                                   additional_covariates_tr) #> fold 1 #> fold 2 #> fold 3 #> fold 4 #> fold 5 plot_cv_trac(cvfit_add_covariates)"},{"path":"/articles/trac-classification-pipeline.html","id":"optional-two-stage-procedure","dir":"Articles","previous_headings":"Model fitting","what":"Optional: Two-stage procedure","title":"trac classification pipeline","text":"cross-validation plot trac classification without additional covariates suggests model minimum loss selects 3 components. can build possible log–ratios based three components run another lasso select important pairs. function second_stage wrapper kind tasks. function internally builds possible log-ratio pairs uses lasso calculated glmnet select predictive log-ratios. determine optimal λ\\lambda uses cross-validation.","code":"set.seed(1) two_stage <- second_stage(Z = ztr, A = A, y = ytr,                           betas = fit[[1]]$alpha[, cvfit$cv[[1]]$ibest],                           method = \"classif\",                           criterion = \"1se\")"},{"path":[]},{"path":"/articles/trac-classification-pipeline.html","id":"evaluation-of-predictive-performance","dir":"Articles","previous_headings":"Reporting","what":"Evaluation of predictive performance","title":"trac classification pipeline","text":"","code":"# get predicted values # trac yhat_te <- predict_trac(fit, new_Z = zte) # trac with additional covariates yhat_te_add_covariates <- predict_trac(fit_add_covariates, new_Z = zte,                                        new_additional_covariates = additional_covariates_te) # sparse log-contrast classification yhat_te_log_contrast <- predict_trac(list(fit_log_contrast), new_Z = zte)  # two-stage procedure yhat_te_two <- predict_second_stage(new_Z = zte, fit = two_stage, output = \"class\") yhat_te_two <- as.numeric(yhat_te_two)  # calculate missclassification error for each methods # trac classification testerr <- colMeans(sign(yhat_te[[1]]) != yte) nnz <- colSums(fit[[1]]$alpha != 0) # trac with additional covariates testerr_add_covariates <- colMeans(sign(yhat_te[[1]]) != yte) nnz_add_covariates <- colSums(fit_add_covariates[[1]]$alpha != 0) # sparse log-contrast classification testerr_log_contrast <- colMeans(sign(yhat_te_log_contrast[[1]]) != yte) nnz_log_contrast <- colSums(fit_log_contrast$beta != 0) # two-stage procedure testerr_two <- mean(yhat_te_two != yte) # plot missclassification error of test split based on number of # selected taxa (trac) tibble(nnz = nnz, testerr = testerr) %>%   ggplot(aes(x = nnz, y = testerr)) +   geom_point() +   geom_vline(xintercept = nnz[cvfit$cv[[1]]$i1se]) # plot missclassification error of test split based on number of # selected taxa (sparse log contrast) tibble(nnz = nnz_log_contrast, testerr = testerr_log_contrast) %>%   ggplot(aes(x = nnz_log_contrast, y = testerr_log_contrast)) +   geom_point() +   geom_vline(xintercept = nnz_log_contrast[cvfit_log_contrast$cv$i1se])"},{"path":"/articles/trac-classification-pipeline.html","id":"reporting-of-results","dir":"Articles","previous_headings":"Reporting","what":"Reporting of Results","title":"trac classification pipeline","text":"following code shows example extract selected components based fitted trac object.","code":"# define the different taxonomic ranks rank_names <- c(\"Kingdom\",                 \"Phylum\",                 \"Class\",                 \"Order\",                 \"Family\",                 \"Genus\",                 \"Species\")  # get non-zero alphas show_nonzeros <- function(x){   enframe(x[x != 0]) %>%     mutate(name = str_remove_all(name, \"[a-z]__\"),            name = str_remove_all(name, \"'\")) %>%     separate(name, into = rank_names, sep = \"::\") %>%     mutate(across(where(is.character), ~replace_na(.x, \" \"))) %>%     arrange(value) %>%     rename(alpha = value) } show_nonzeros(fit[[1]]$alpha[, cvfit$cv[[1]]$i1se]) %>%   kable() #> Warning: Expected 7 pieces. Missing pieces filled with `NA` in 2 rows [1, 2]."},{"path":[]},{"path":"/articles/trac-example.html","id":"set-up-traintest-splits-and-take-logarithm","dir":"Articles","previous_headings":"","what":"Set up train/test splits and take logarithm","title":"Using `trac` to build tree-aggregated predictive models","text":"Let’s start splitting data train test set. ’ll take 2/3 observations training. Since trac operates log-contrast framework, take log feature matrix.","code":"set.seed(123) ntot <- length(sCD14$y) n <- round(2/3 * ntot) tr <- sample(ntot, n) log_pseudo <- function(x, pseudo_count = 1) log(x + pseudo_count) ytr <- sCD14$y[tr] yte <- sCD14$y[-tr] ztr <- log_pseudo(sCD14$x[tr, ]) zte <- log_pseudo(sCD14$x[-tr, ])"},{"path":"/articles/trac-example.html","id":"apply-trac","dir":"Articles","previous_headings":"","what":"Apply trac","title":"Using `trac` to build tree-aggregated predictive models","text":"now solve trac optimization problem using path algorithm (implemented c-lasso Python package). function trac returns solutions grid values tuning parameter λ\\lambda. grid’s minimal value number points controlled min_frac nlam, respectively. default, trac gives us model known “trac (=1)” paper. choices weights, see section weights .","code":"fit <- trac(ztr, ytr, A = sCD14$A, min_frac = 1e-2, nlam = 30)"},{"path":"/articles/trac-example.html","id":"looking-at-the-trac-output","dir":"Articles","previous_headings":"","what":"Looking at the trac output","title":"Using `trac` to build tree-aggregated predictive models","text":"can look trac regularization path. default, function plot_trac_path shows alpha coefficients. alpha coefficient corresponding node tree. example, early path following: can also plot beta values (coefficients corresponding leaf taxa): see amount regularization increases, individual beta coefficients tend fuse together (corresponding aggregation taxa induced trac regularizer). Next, like select value tuning parameter. using cross validation.","code":"plot_trac_path(fit) show_nonzeros <- function(x) x[x != 0] show_nonzeros(fit[[1]]$alpha[, 2]) #> Life::Bacteria::Firmicutes::Clostridia::Clostridiales::Ruminococcaceae  #>                                                               306.4128  #> Life::Bacteria::Firmicutes::Clostridia::Clostridiales::Lachnospiraceae  #>                                                              -306.4128 plot_trac_path(fit, coef = \"beta\")"},{"path":"/articles/trac-example.html","id":"cross-validate-trac-to-choose-tuning-parameter","dir":"Articles","previous_headings":"","what":"Cross validate trac to choose tuning parameter","title":"Using `trac` to build tree-aggregated predictive models","text":"function cv_trac default performs 5-fold cross validation. can use function plot_cv_trac visualize. two vertical lines show us minimum CV curve “1 SE rule” solution. Using 1SE rule results following nonzero alpha coefficients.","code":"cvfit <- cv_trac(fit, Z = ztr, y = ytr, A = sCD14$A) #> fold 1 #> fold 2 #> fold 3 #> fold 4 #> fold 5 plot_cv_trac(cvfit) cvfit$cv[[1]]$ibest #> [1] 20 cvfit$cv[[1]]$i1se #> [1] 8 show_nonzeros(fit[[1]]$alpha[, cvfit$cv[[1]]$i1se]) #>                                                         Life::Bacteria::Actinobacteria  #>                                                                              -501.4342  #> Life::Bacteria::Bacteroidetes::Bacteroidia::Bacteroidales::Bacteroidaceae::Bacteroides  #>                                                                               286.8039  #>                 Life::Bacteria::Firmicutes::Clostridia::Clostridiales::Ruminococcaceae  #>                                                                              2221.7522  #>                 Life::Bacteria::Firmicutes::Clostridia::Clostridiales::Lachnospiraceae  #>                                                                             -1644.8562  #>                                                                         Life::Bacteria  #>                                                                              -362.2657"},{"path":"/articles/trac-example.html","id":"making-predictions","dir":"Articles","previous_headings":"","what":"Making predictions","title":"Using `trac` to build tree-aggregated predictive models","text":"can apply trac model make predictions test set compute mean squared error test set. can make plot test error function number non-zero alpha coefficients.","code":"yhat_te <- predict_trac(fit, new_Z = zte) testerr <- colMeans((yhat_te[[1]] - yte)^2) nnz <- colSums(fit[[1]]$alpha != 0) library(tidyverse) tibble(nnz = nnz, testerr = testerr) %>%   ggplot(aes(x = nnz, y = testerr)) +   geom_point() +   geom_vline(xintercept = nnz[cvfit$cv[[1]]$i1se])"},{"path":"/articles/trac-example.html","id":"weights","dir":"Articles","previous_headings":"","what":"Weights","title":"Using `trac` to build tree-aggregated predictive models","text":"user can specify set node-specific weights penalty. described trac paper, straightforward choice take power number leaves node: wu=|Lu|−. w_u=|L_u|^{-}.  apologies user, weights notation overloaded, means notation w function trac ww referred paper different way explain now. package, weights w refer weights trac optimization problem parameterized terms gamma whereas paper’s equation (2), ww refers weights trac optimization problem parameterized terms alpha. explained appendix paper, αu=γu⋅|Lu|\\alpha_u=\\gamma_u\\cdot|L_u|. means weights use package taken |L_u| times larger paper. Thus, paper writes “trac (=1)”, corresponds trac function getting input w ones (default). paper writes “trac (=1/2)”, corresponds trac function called follows:","code":"fit2 <- trac(ztr, ytr, A = sCD14$A, min_frac = 1e-2,              nlam = 30, w = Matrix::colSums(sCD14$A)^0.5)"},{"path":"/articles/trac-example.html","id":"other-base-levels","dir":"Articles","previous_headings":"","what":"Other base levels","title":"Using `trac` to build tree-aggregated predictive models","text":"trac package can perform flexible data-adaptive aggregation starting base level aggregation. , started OTU-level data leaves tree. However, users may prefer first aggregate fixed level summing counts within certain taxonomic level. example, start aggregating family level applying trac: can now proceed ","code":"sCD14_family <- aggregate_to_level(sCD14$x, sCD14$y, sCD14$A, sCD14$tax, level = 6, collapse = TRUE) fit_family <- trac(log_pseudo(sCD14_family$x[tr, ]),                    sCD14_family$y[tr],                    sCD14_family$A,                    min_frac = 1e-2, nlam = 30)"},{"path":"/articles/trac-example.html","id":"sparse-log-contrast","dir":"Articles","previous_headings":"","what":"Sparse Log-Contrast","title":"Using `trac` to build tree-aggregated predictive models","text":"One can also fit sparse log-contrast models trac.","code":"fit_slc <- sparse_log_contrast(ztr, ytr, min_frac = 1e-2, nlam = 30) cvfit_slc <- cv_sparse_log_contrast(fit_slc, Z = ztr, y = ytr) #> fold 1 #> fold 2 #> fold 3 #> fold 4 #> fold 5 yhat_te_slc <- predict_trac(list(fit_slc), new_Z = zte)[[1]] testerr_slc <- colMeans((yhat_te_slc - yte)^2) nnz_slc <- colSums(fit_slc$beta != 0) tibble(nnz = nnz_slc, testerr = testerr_slc) %>%   ggplot(aes(x = nnz, y = testerr)) +   geom_point() +   geom_vline(xintercept = nnz_slc[cvfit$cv[[1]]$i1se])"},{"path":"/articles/trac-installation.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Installation","text":"trac internally uses c-lasso solver (Simpson, Combettes, Müller 2021) implemented Python reticulate call c-lasso R.","code":"# install.packages(\"reticulate\") library(reticulate)"},{"path":[]},{"path":[]},{"path":"/articles/trac-installation.html","id":"install-miniconda","dir":"Articles","previous_headings":"Python > Install c-lasso within R with reticulate","what":"Install Miniconda","title":"Installation","text":"sure python 3.6 (later) installed use following code. installation Python asked install Miniconda guided console. know python installed install Miniconda Python 3.6.3 : Alternatively consider following instruction Miniconda installation page.","code":"py_config() install_miniconda()"},{"path":"/articles/trac-installation.html","id":"install-c-lasso","dir":"Articles","previous_headings":"Python > Install c-lasso within R with reticulate","what":"Install c-lasso","title":"Installation","text":"First need install dependencies c-lasso, namely numpy (Harris et al. 2020), scipy (Virtanen et al. 2020), matplotlib (Hunter 2007) pandas (McKinney 2010). Afterwards can install c-lasso.","code":"conda_install(packages = c(\"numpy\", \"scipy\", \"matplotlib\", \"pandas\")) conda_install(packages = \"c-lasso\", pip = TRUE)"},{"path":"/articles/trac-installation.html","id":"install-c-lasso-within-the-terminal","dir":"Articles","previous_headings":"Python","what":"Install c-lasso within the terminal","title":"Installation","text":"Install numpy, scipy, matplotlib, pandas c-lasso within virtual / conda environment. (Note: Depending operating system one use commas ) Also consider pip3 work. loading trac specify python path ","code":"pip install numpy, scipy, matplotlib, pandas, c-lasso use_python(path)"},{"path":"/articles/trac-installation.html","id":"install-trac","dir":"Articles","previous_headings":"","what":"Install trac","title":"Installation","text":"","code":"# if devtools is not installed # install.packages(\"devtools\") devtools::install_github(\"jacobbien/trac\")"},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Jacob Bien. Author, maintainer. Christian Mueller. Author. Xiaohan Yan. Author.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bien, J., Yan, X., Simpson, L., & Müller, C. L. (2021). Tree-aggregated predictive modeling microbiome data. Scientific Reports, 11(1), 1-13.","code":"@Article{,   title = {Tree-aggregated predictive modeling of microbiome data},   author = {Jacob Bien and Xiaohan Yan and Léo Simpson and Christian L Müller},   journal = {Scientific Reports},   year = {2021},   volume = {11},   number = {1},   pages = {1-13}, }"},{"path":"/index.html","id":"trac-tree-based-aggregation-of-compositional-data","dir":"","previous_headings":"","what":"Tree-based Aggregation of Compositional Data","title":"Tree-based Aggregation of Compositional Data","text":"R package, called trac, performs tree-based aggregation compositional data particular focus microbiome data. Users encouraged visit package’s website vignette. implements method proposed Tree-Aggregated Predictive Modeling Microbiome Data. uses internally c-lasso solver Python (described paper). package also includes fast solver standard sparse log-contrast regression. easiest way install trac using devtools R package (already installed, open R run install.packages(\"devtools\")). install trac, run R.","code":"devtools::install_github(\"jacobbien/trac\")"},{"path":"/reference/aggregate_to_level.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregate data to a fixed level — aggregate_to_level","title":"Aggregate data to a fixed level — aggregate_to_level","text":"function aggregates data set fixed level taxonomy.  example, aggregating Phylum level, sum columns x corresponding OTUs/ASVs Phylum.  also adjusts tree information (particular , tree, tax) new smaller problem.","code":""},{"path":"/reference/aggregate_to_level.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregate data to a fixed level — aggregate_to_level","text":"","code":"aggregate_to_level(x, y, A, tax, level = 7, collapse = FALSE)"},{"path":"/reference/aggregate_to_level.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregate data to a fixed level — aggregate_to_level","text":"x n p data matrix counts, n number samples, p number OTUs/ASVs. y response vector length n p (t_size-1) binary matrix giving tree structure (t_size total number nodes -1 include root).  created function phylo_to_A. tax tax table, p number--levels matrix, cell ij gives name level j ancestor OTU/ASV . level level aggregating ? collapse see tax_table_to_phylo","code":""},{"path":"/reference/check_additional_covariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Check non-compositional inputs — check_additional_covariates","title":"Check non-compositional inputs — check_additional_covariates","text":"Check additional non-compositional inputs NAs number observations compositional inputs","code":""},{"path":"/reference/check_additional_covariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check non-compositional inputs — check_additional_covariates","text":"","code":"check_additional_covariates(   additional_covariates,   n,   w_additional_covariates,   p_x )"},{"path":"/reference/check_additional_covariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check non-compositional inputs — check_additional_covariates","text":"additional_covariates new data matrix (see additional_covariates trac) n number observations w_additional_covariates weights estimation coefficients p_x vector number additional non-compositional covariates","code":""},{"path":"/reference/check_additional_covariates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check non-compositional inputs — check_additional_covariates","text":"errors requirements met","code":""},{"path":"/reference/check_method.html","id":null,"dir":"Reference","previous_headings":"","what":"Check method input and other hyperparameter — check_method","title":"Check method input and other hyperparameter — check_method","text":"Check method input hyperparameter classification correctly specified","code":""},{"path":"/reference/check_method.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check method input and other hyperparameter — check_method","text":"","code":"check_method(method, y, rho = 0)"},{"path":"/reference/check_method.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check method input and other hyperparameter — check_method","text":"method method (see method trac) y outcome (see y trac) rho hyperparameter huberized loss classification (see rhofrom trac)","code":""},{"path":"/reference/check_method.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check method input and other hyperparameter — check_method","text":"list vector indicating method used outcome","code":""},{"path":"/reference/cv_sparse_log_contrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform cross validation for tuning parameter selection for sparse log contrast — cv_sparse_log_contrast","title":"Perform cross validation for tuning parameter selection for sparse log contrast — cv_sparse_log_contrast","text":"function called calling sparse_log_contrast. performs nfold-fold cross validation.","code":""},{"path":"/reference/cv_sparse_log_contrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform cross validation for tuning parameter selection for sparse log contrast — cv_sparse_log_contrast","text":"","code":"cv_sparse_log_contrast(   fit,   Z,   y,   folds = NULL,   nfolds = 5,   summary_function = stats::median,   additional_covariates = NULL )"},{"path":"/reference/cv_sparse_log_contrast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform cross validation for tuning parameter selection for sparse log contrast — cv_sparse_log_contrast","text":"fit output sparse_log_contrast function. Z, y, additional_covariates arguments passed sparse_log_contrast. C taken fit object. folds partition 1:nrow(Z). nfolds number folds cross-validation summary_function combine errors calculated observation within fold (e.g. mean median)","code":""},{"path":"/reference/cv_trac.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform cross validation for tuning parameter selection — cv_trac","title":"Perform cross validation for tuning parameter selection — cv_trac","text":"function called calling trac.  performs nfold-fold cross validation. classification metric misclassification error.","code":""},{"path":"/reference/cv_trac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform cross validation for tuning parameter selection — cv_trac","text":"","code":"cv_trac(   fit,   Z,   y,   A,   additional_covariates = NULL,   folds = NULL,   nfolds = 5,   summary_function = stats::median,   stratified = FALSE )"},{"path":"/reference/cv_trac.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform cross validation for tuning parameter selection — cv_trac","text":"fit output trac function. Z, y, , additional_covariates arguments passed trac folds partition 1:nrow(Z). nfolds number folds cross-validation summary_function combine errors calculated observation within fold (e.g. mean median) (regression task) stratified TRUE use stratified folds based target variable classification. Default set FALSE.","code":""},{"path":"/reference/get_categorical_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if additional variables are categorical — get_categorical_variables","title":"Check if additional variables are categorical — get_categorical_variables","text":"Check additional non-compositional covariates categorical based type column. column binary factor assumed categorical variable. Useful transform input.","code":""},{"path":"/reference/get_categorical_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if additional variables are categorical — get_categorical_variables","text":"","code":"get_categorical_variables(X)"},{"path":"/reference/get_categorical_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if additional variables are categorical — get_categorical_variables","text":"X see additional_covariates trac","code":""},{"path":"/reference/get_categorical_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if additional variables are categorical — get_categorical_variables","text":"list vector indicating categorical , number categorical variables","code":""},{"path":"/reference/get_probability_cv.html","id":null,"dir":"Reference","previous_headings":"","what":"5-fold cross-validation to find the optimal parameters A and B for probabilistic output. Obtain the decision values and pass to the platt algorithm for each lambda — get_probability_cv","title":"5-fold cross-validation to find the optimal parameters A and B for probabilistic output. Obtain the decision values and pass to the platt algorithm for each lambda — get_probability_cv","text":"5-fold cross-validation find optimal parameters B probabilistic output. Obtain decision values pass platt algorithm lambda","code":""},{"path":"/reference/get_probability_cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"5-fold cross-validation to find the optimal parameters A and B for probabilistic output. Obtain the decision values and pass to the platt algorithm for each lambda — get_probability_cv","text":"","code":"get_probability_cv(   Z,   additional_covariates,   A,   y,   method,   w,   w_additional_covariates,   fraclist,   nfolds = 5,   eps,   n_lambda )"},{"path":"/reference/get_probability_cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"5-fold cross-validation to find the optimal parameters A and B for probabilistic output. Obtain the decision values and pass to the platt algorithm for each lambda — get_probability_cv","text":"Z arguments passed trac additional_covariates arguments passed trac arguments passed trac y arguments passed trac method arguments passed trac w arguments passed trac w_additional_covariates arguments passed trac fraclist arguments passed trac nfolds number folds eps convergence criterion n_lambda number lambdas","code":""},{"path":"/reference/get_probability_cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"5-fold cross-validation to find the optimal parameters A and B for probabilistic output. Obtain the decision values and pass to the platt algorithm for each lambda — get_probability_cv","text":"matrix hyperparameter B columns","code":""},{"path":"/reference/get_probability_platt.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate parameters A and B based on Platt — get_probability_platt","title":"Calculate parameters A and B based on Platt — get_probability_platt","text":"algorithm based pseudo-code ","code":""},{"path":"/reference/get_probability_platt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate parameters A and B based on Platt — get_probability_platt","text":"","code":"get_probability_platt(decision_values, label, eps)"},{"path":"/reference/get_probability_platt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate parameters A and B based on Platt — get_probability_platt","text":"decision_values output score trac classification (see y trac) label labels see y trac eps threshold convergence","code":""},{"path":"/reference/get_probability_platt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate parameters A and B based on Platt — get_probability_platt","text":"B","code":""},{"path":"/reference/make_folds_stratified.html","id":null,"dir":"Reference","previous_headings":"","what":"This function creates stratified folds for cross validation for unbalanced data. The code is adopted from ggb make_folds — make_folds_stratified","title":"This function creates stratified folds for cross validation for unbalanced data. The code is adopted from ggb make_folds — make_folds_stratified","text":"function creates stratified folds cross validation unbalanced data. code adopted ggb make_folds","code":""},{"path":"/reference/make_folds_stratified.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function creates stratified folds for cross validation for unbalanced data. The code is adopted from ggb make_folds — make_folds_stratified","text":"","code":"make_folds_stratified(n, nfolds, y)"},{"path":"/reference/make_folds_stratified.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"This function creates stratified folds for cross validation for unbalanced data. The code is adopted from ggb make_folds — make_folds_stratified","text":"n number observations nfolds number folds y variable group assignment.","code":""},{"path":"/reference/malawi.html","id":null,"dir":"Reference","previous_headings":"","what":"malawi vs venezuela, adults only — malawi","title":"malawi vs venezuela, adults only — malawi","text":"subset \"malawi vs venezuela, adults \" task Microbiome Learning Repo. task predict whether individuals live Malawi Venezuela based OTU count table. OTUs occur less 10% samples excluded. Bacteria included. taxonomic table OTUs obtained greengenes reference database. data originally published Yatsunenko, T., Rey, F. E., Manary, M. J., Trehan, ., Dominguez-Bello, M. G., Contreras, M., ... & Gordon, J. . (2012). Human gut microbiome viewed across age geography. nature, 486(7402), 222-227..","code":""},{"path":"/reference/malawi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"malawi vs venezuela, adults only — malawi","text":"","code":"malawi"},{"path":"/reference/malawi.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"malawi vs venezuela, adults only — malawi","text":"phyloseq object: otu_table OTU count table 54 rows corresponding subjects 5008 columns corresponding OTUs tax_table Taxonomic table taxonomic assignment different levels OTUs. names OTUs saved rownames. 5008 rows correspond different OTUS 7 columns different levels taxonomic tree (Kingdom, Phylum, Class, Order, Family, Genus, Species) sam_data Meta data different observations. Contains labels Vars additional covariates sex (binary) age (numeric)","code":""},{"path":"/reference/normalization_additional_covariates.html","id":null,"dir":"Reference","previous_headings":"","what":"Functions transform non-compositional input — normalization_additional_covariates","title":"Functions transform non-compositional input — normalization_additional_covariates","text":"normalize metadata. (x-mean(x)) / norm(x) numerical variables 0/1 categorical variables provided factor","code":""},{"path":"/reference/normalization_additional_covariates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functions transform non-compositional input — normalization_additional_covariates","text":"","code":"normalization_additional_covariates(additional_covariates, p_x, intercept)"},{"path":"/reference/normalization_additional_covariates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functions transform non-compositional input — normalization_additional_covariates","text":"additional_covariates new data matrix (see additional_covariates trac) p_x number additional covariates intercept Boolean normalization applied","code":""},{"path":"/reference/normalization_additional_covariates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functions transform non-compositional input — normalization_additional_covariates","text":"list vector indicating categorical , number categorical variables, vector means l2 norm normalized variables","code":""},{"path":"/reference/phylo_to_A.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert from phylo to the A matrix used in trac. Note this is similar to the A used in rare, but with the column of all ones (for the root) removed — phylo_to_A","title":"Convert from phylo to the A matrix used in trac. Note this is similar to the A used in rare, but with the column of all ones (for the root) removed — phylo_to_A","text":"Convert phylo matrix used trac.  Note similar used rare, column ones (root) removed","code":""},{"path":"/reference/phylo_to_A.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert from phylo to the A matrix used in trac. Note this is similar to the A used in rare, but with the column of all ones (for the root) removed — phylo_to_A","text":"","code":"phylo_to_A(phy)"},{"path":"/reference/phylo_to_A.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert from phylo to the A matrix used in trac. Note this is similar to the A used in rare, but with the column of all ones (for the root) removed — phylo_to_A","text":"phy phylo object ape package","code":""},{"path":"/reference/plot_cv_trac.html","id":null,"dir":"Reference","previous_headings":"","what":"Make a plot of the output of cv_trac — plot_cv_trac","title":"Make a plot of the output of cv_trac — plot_cv_trac","text":"Make plot output cv_trac","code":""},{"path":"/reference/plot_cv_trac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make a plot of the output of cv_trac — plot_cv_trac","text":"","code":"plot_cv_trac(cvfit_trac, iw = NULL, superimpose = TRUE)"},{"path":"/reference/plot_cv_trac.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make a plot of the output of cv_trac — plot_cv_trac","text":"cvfit_trac object returned cv_trac. iw vector indices specifying weight sequence solutions include superimpose whether superimpose","code":""},{"path":"/reference/plot_trac_path.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot trac coefficient path — plot_trac_path","title":"Plot trac coefficient path — plot_trac_path","text":"Plot trac coefficient path","code":""},{"path":"/reference/plot_trac_path.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot trac coefficient path — plot_trac_path","text":"","code":"plot_trac_path(fit, iw = 1, coef = c(\"alpha\", \"beta\", \"gamma\"))"},{"path":"/reference/plot_trac_path.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot trac coefficient path — plot_trac_path","text":"fit object returned trac. iw index specifying weight sequence solution plot coef type parameter show plot","code":""},{"path":"/reference/predict_second_stage.html","id":null,"dir":"Reference","previous_headings":"","what":"Make predictions based on a second_stage fit — predict_second_stage","title":"Make predictions based on a second_stage fit — predict_second_stage","text":"Make predictions based second_stage fit","code":""},{"path":"/reference/predict_second_stage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make predictions based on a second_stage fit — predict_second_stage","text":"","code":"predict_second_stage(   new_Z,   new_additional_covariates = NULL,   fit,   output = c(\"raw\", \"probability\", \"class\") )"},{"path":"/reference/predict_second_stage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make predictions based on a second_stage fit — predict_second_stage","text":"new_Z new data matrix (see Z second_stage) new_additional_covariates new data matrix (see additional_covariates second_stage) fit output function second_stage output string  either \"raw\", \"probability\" \"class\" relevant classification tasks","code":""},{"path":"/reference/predict_second_stage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make predictions based on a second_stage fit — predict_second_stage","text":"vector nrow(new_Z) + nrow(new_additional_covariates) predictions.","code":""},{"path":"/reference/predict_sparse_log_contrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Make predictions based on a sparse log contrast fit — predict_sparse_log_contrast","title":"Make predictions based on a sparse log contrast fit — predict_sparse_log_contrast","text":"Make predictions based sparse log contrast fit","code":""},{"path":"/reference/predict_sparse_log_contrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make predictions based on a sparse log contrast fit — predict_sparse_log_contrast","text":"","code":"predict_sparse_log_contrast(   fit,   new_Z,   new_additional_covariates = NULL,   output = c(\"raw\", \"probability\", \"class\") )"},{"path":"/reference/predict_sparse_log_contrast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make predictions based on a sparse log contrast fit — predict_sparse_log_contrast","text":"fit output function sparse_log_contrast new_Z new data matrix (see Z sparse_log_contrast) new_additional_covariates new data matrix (see additional_covariates sparse_log_contrast) output string  either \"raw\", \"probability\" \"class\" relevant classification tasks","code":""},{"path":"/reference/predict_sparse_log_contrast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make predictions based on a sparse log contrast fit — predict_sparse_log_contrast","text":"vector nrow(new_Z) predictions.","code":""},{"path":"/reference/predict_trac.html","id":null,"dir":"Reference","previous_headings":"","what":"Make predictions based on a trac fit — predict_trac","title":"Make predictions based on a trac fit — predict_trac","text":"Make predictions based trac fit","code":""},{"path":"/reference/predict_trac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make predictions based on a trac fit — predict_trac","text":"","code":"predict_trac(   fit,   new_Z,   new_additional_covariates = NULL,   output = c(\"raw\", \"probability\", \"class\") )"},{"path":"/reference/predict_trac.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make predictions based on a trac fit — predict_trac","text":"fit output function trac new_Z new data matrix (see Z trac) new_additional_covariates new data matrix (see additional_covariates trac) output string  either \"raw\", \"probability\" \"class\" relevant classification tasks","code":""},{"path":"/reference/predict_trac.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make predictions based on a trac fit — predict_trac","text":"vector nrow(new_Z) predictions.","code":""},{"path":"/reference/probability_transform.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform the score output to probabilistic output — probability_transform","title":"Transform the score output to probabilistic output — probability_transform","text":"following idea Chapter 3.2 ","code":""},{"path":"/reference/probability_transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform the score output to probabilistic output — probability_transform","text":"","code":"probability_transform(yhat, A, B)"},{"path":"/reference/probability_transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform the score output to probabilistic output — probability_transform","text":"yhat score based output trac (see y trac) Hyperparameter probabilistic transformation B Hyperparameter probabilistic transformation","code":""},{"path":"/reference/probability_transform.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform the score output to probabilistic output — probability_transform","text":"Probabilistic output","code":""},{"path":"/reference/refit_sparse_log_contrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Refit subject to sparsity constraints — refit_sparse_log_contrast","title":"Refit subject to sparsity constraints — refit_sparse_log_contrast","text":"Given output sparse_log_contrast, solves least squares problem compositional constraint features selected sparse_log_contrast.","code":""},{"path":"/reference/refit_sparse_log_contrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refit subject to sparsity constraints — refit_sparse_log_contrast","text":"","code":"refit_sparse_log_contrast(fit, Z, y, tol = 1e-05)"},{"path":"/reference/refit_sparse_log_contrast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refit subject to sparsity constraints — refit_sparse_log_contrast","text":"fit output sparse_log_contrast Z, y arguments passed sparse_log_contrast tol tolerance deciding whether beta value zero","code":""},{"path":"/reference/refit_sparse_log_contrast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refit subject to sparsity constraints — refit_sparse_log_contrast","text":"minimize_beta, beta0 1/(2n) || y - beta0 1_n - Z beta ||^2 subject beta_nonselected = 0, 1_p^T beta = 0","code":""},{"path":"/reference/refit_sparse_log_contrast_classif.html","id":null,"dir":"Reference","previous_headings":"","what":"Refit log-contrast for classification to sparsity constraint — refit_sparse_log_contrast_classif","title":"Refit log-contrast for classification to sparsity constraint — refit_sparse_log_contrast_classif","text":"Given output sparse_log_contrast, solves classification problem compositional constraint features selected sparse_log_contrast. contrast refit_sparse_log_contrast function refit one model specified i_selected component_selected. i_selected usually comes i1se cross-validation output.","code":""},{"path":"/reference/refit_sparse_log_contrast_classif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refit log-contrast for classification to sparsity constraint — refit_sparse_log_contrast_classif","text":"","code":"refit_sparse_log_contrast_classif(   fit,   i_selected = NULL,   Z,   y,   additional_covariates = NULL,   tol = 1e-05,   component_selected = NULL )"},{"path":"/reference/refit_sparse_log_contrast_classif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refit log-contrast for classification to sparsity constraint — refit_sparse_log_contrast_classif","text":"fit output sparse_log_contrast i_selected indicator lambda selected based example cross-validation procedure Z, y, additional_covariates arguments passed sparse_log_contrast tol tolerance deciding whether beta value zero component_selected vector indices component include","code":""},{"path":"/reference/refit_trac.html","id":null,"dir":"Reference","previous_headings":"","what":"Refit subject to sparsity constraints — refit_trac","title":"Refit subject to sparsity constraints — refit_trac","text":"Given output trac, solves least squares problem compositional constraint features selected trac.","code":""},{"path":"/reference/refit_trac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refit subject to sparsity constraints — refit_trac","text":"","code":"refit_trac(fit, Z, y, A, tol = 1e-05)"},{"path":"/reference/refit_trac.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refit subject to sparsity constraints — refit_trac","text":"fit output trac Z, y, arguments passed trac tol tolerance deciding whether gamma value zero","code":""},{"path":"/reference/refit_trac.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refit subject to sparsity constraints — refit_trac","text":"minimize_beta, beta0, gamma 1/(2n) || y - beta0 1_n - Z beta ||^2 subject gamma_trac nonselected = 0, beta = gamma, 1_p^T beta = 0","code":""},{"path":"/reference/rescale_betas.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-scale betas of normalized variables — rescale_betas","title":"Re-scale betas of normalized variables — rescale_betas","text":"Re-scales betas normalized covariates original scale non-zero betas","code":""},{"path":"/reference/rescale_betas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-scale betas of normalized variables — rescale_betas","text":"","code":"rescale_betas(beta, p_x, p, n_numeric, categorical, xs, xm)"},{"path":"/reference/rescale_betas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-scale betas of normalized variables — rescale_betas","text":"beta estimated coefficients p_x count additional non-compositional covariates p count compositional covariates n_numeric count numerical non-compositional covariates categorical boolean vector indicating additional non-compositional covariates categorical (see get_categorical_variables) xs vector l2 norm (seenormalization_additional_covariates) xm vector means (seenormalization_additional_covariates)","code":""},{"path":"/reference/rescale_betas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-scale betas of normalized variables — rescale_betas","text":"matrix re-scaled betas","code":""},{"path":"/reference/sCD14.html","id":null,"dir":"Reference","previous_headings":"","what":"sCD14 data — sCD14","title":"sCD14 data — sCD14","text":"Gut (HIV) data used Tree-Aggregated Predictive Modeling Microbiome Data. processed based phyloseq object provided Javier Rivera-Pinto. BCN0 (Bacelona test dataset) Gut Microbiota Linked Sexual Preference HIV Infection.","code":""},{"path":"/reference/sCD14.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"sCD14 data — sCD14","text":"","code":"sCD14"},{"path":"/reference/sCD14.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"sCD14 data — sCD14","text":"named list: y Vector n = 152 soluble CD14 levels units pg/ml x Matrix fecal 16S rRNA amplicon data, n = 152 rows corresponding people p = 539 columns corresponding OTUs. tree Taxonomic tree class phylo tax data frame containing taxonomic information OTU binary matrix encoding tree structure p = 539 rows, corresponding leaves, 626 columns, corresponding non-root nodes tree.  See Tree-Aggregated Predictive Modeling Microbiome Data definition .","code":""},{"path":"/reference/second_stage.html","id":null,"dir":"Reference","previous_headings":"","what":"Two stage regression — second_stage","title":"Two stage regression — second_stage","text":"Perform two stage fitting procedure similar one proposed Bates, S., & Tibshirani, R. (2019). Log‐ratio lasso: Scalable, sparse estimation log‐ratio models. Biometrics, 75(2), 613-624. function uses selected components trac log-ratio fits sparse model based possible log-ratios.","code":""},{"path":"/reference/second_stage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Two stage regression — second_stage","text":"","code":"second_stage(   Z,   A = NULL,   y,   additional_covariates = NULL,   betas,   topk = NULL,   nfolds = 5,   method = c(\"regr\", \"classif\"),   criterion = c(\"1se\", \"min\"),   alpha = 0 )"},{"path":"/reference/second_stage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Two stage regression — second_stage","text":"Z n p matrix containing log(X) (see Z trac) p (t_size-1) binary matrix giving tree structure (t_size total number nodes -1 include root). needed trac based models. (see trac). = NULL, sparse-log contrast model assumed. y n vector (response) (see y trac) additional_covariates n p' matrix containing additional covariates, (see additional_covariates trac). Non-compositional components currently penalized lasso betas pre-screened coefficients (see output gamma trac output beta sparse_log_contrast) topk maximum number pre-screened coefficients consider. Default NULL. nfolds number folds method string estimation method use \"regr\" \"classif\" criterion criterion used select coefficients \"1se\" \"min\" alpha nudge model select higher lower level tree. relevant trac based models.","code":""},{"path":"/reference/second_stage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Two stage regression — second_stage","text":"list : log_ratios: betas log ratios; index: dataframe index pre selected coefficients log ratio name; : taxonomic tree information; method: regression classification; cv_glmnet: output glmnet, useful prediction; criterion: criterion used select lambda based cv (cross validation)","code":""},{"path":"/reference/second_stage.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Two stage regression — second_stage","text":"Fit trac sparse-log contrast extract selected components. Fit second-stage based selected components.","code":""},{"path":"/reference/sparse_log_contrast.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform sparse log-contrast regression — sparse_log_contrast","title":"Perform sparse log-contrast regression — sparse_log_contrast","text":"Solves constrained lasso problem using CLASSO module Python.  optimization problem ","code":""},{"path":"/reference/sparse_log_contrast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform sparse log-contrast regression — sparse_log_contrast","text":"","code":"sparse_log_contrast(   Z,   y,   additional_covariates = NULL,   C = NULL,   fraclist = NULL,   nlam = 20,   min_frac = 1e-04,   method = c(\"regr\", \"classif\", \"classif_huber\"),   w_additional_covariates = NULL,   intercept = TRUE,   normalized = TRUE,   rho = 0 )"},{"path":"/reference/sparse_log_contrast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform sparse log-contrast regression — sparse_log_contrast","text":"Z n p matrix containing log(X) y n vector (response) additional_covariates n p' matrix containing additional covariates / features C m p matrix. Default row vector ones. fraclist (optional) vector tuning parameter multipliers. (0, 1]. nlam number tuning parameters (ignored fraclist non-NULL) min_frac smallest value tuning parameter multiplier (ignored fraclist non-NULL) method string estimation method use (\"regr\", \"classif\", \"classif_huber\") w_additional_covariates vector positive weights length ncol(additional_covariates) (default: equal 1). intercept works classification! intercept fitted. Default TRUE, set FALSE intercept included normalized TRUE normalize additional covariates. case calculation covariate / feature: (X-X_mean) / ||X||_2 weights transformed back original scale. rho value huberized classification loss. Default = 0.0.","code":""},{"path":"/reference/sparse_log_contrast.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform sparse log-contrast regression — sparse_log_contrast","text":"Regression: minimize_beta, beta0 1/(2n) || y - beta0 1_n - Zagg_clr beta ||^2 + lamda_max * frac || beta ||1 subject C beta = 0 Classification: minimizebeta, beta0 max(1 - y_i(beta0 + Z_clr_i * beta), 0)^2 + lambda_max * frac || W * beta ||_1 subject C beta = 0 Default C = 1_p^T, C can general matrix. Observe tuning parameter specified \"frac\", fraction lamda_max (smallest value beta nonzero).","code":""},{"path":"/reference/tax_table_to_phylo.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a tax table to a phylo object — tax_table_to_phylo","title":"Convert a tax table to a phylo object — tax_table_to_phylo","text":"mostly function .phylo.formula ape package modified interior nodes get labeled. Note: assumes single quotes around labels.","code":""},{"path":"/reference/tax_table_to_phylo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a tax table to a phylo object — tax_table_to_phylo","text":"","code":"tax_table_to_phylo(x, data = parent.frame(), collapse = TRUE, ...)"},{"path":"/reference/tax_table_to_phylo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a tax table to a phylo object — tax_table_to_phylo","text":"x right-side formula describing taxonomic relationship:     ~C1/C2/.../Cn. data data.frame look variables (default     user's workspace). collapse logical value specifying whether collapse single     nodes returned tree (see details). ... arguments passed methods.","code":""},{"path":"/reference/tax_table_to_phylo.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Convert a tax table to a phylo object — tax_table_to_phylo","text":"Julien Dutheil dutheil@evolbio.mpg.de Eric Marcon, modified Jacob Bien","code":""},{"path":"/reference/trac.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform tree-based aggregation — trac","title":"Perform tree-based aggregation — trac","text":"Solves weighted aggregation problem using CLASSO module Python.  optimization problems :","code":""},{"path":"/reference/trac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform tree-based aggregation — trac","text":"","code":"trac(   Z,   y,   A,   additional_covariates = NULL,   fraclist = NULL,   nlam = 20,   min_frac = 1e-04,   w = NULL,   w_additional_covariates = NULL,   method = c(\"regr\", \"classif\", \"classif_huber\"),   intercept = TRUE,   normalized = TRUE,   rho = 0,   output = c(\"raw\", \"probability\") )"},{"path":"/reference/trac.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform tree-based aggregation — trac","text":"Z n p matrix containing log(X) y n vector (response) p (t_size-1) binary matrix giving tree structure (t_size total number nodes -1 include root) additional_covariates n p' matrix containing additional covariates / features fraclist (optional) vector tuning parameter multipliers.  list length num_w vectors. (0, 1]. nlam number tuning parameters (ignored fraclist non-NULL) min_frac smallest value tuning parameter multiplier (ignored fraclist non-NULL) w vector positive weights length t_size - 1 (default: equal 1). list num_w vectors. w_additional_covariates vector positive weights length ncol(additional_covariates) (default: equal 1). method string estimation method use (\"regr\", \"classif\", \"classif_huber\") intercept works classification! intercept fitted. Default TRUE, set FALSE intercept included normalized TRUE normalize additional covariates. case calculation covariate / feature: (X-X_mean) / ||X||_2 weights transformed back original scale. rho value huberized classification loss. Default = -0.0. output relevant classification. String indicating whether raw score output probability class 1 used. probability estimated Platt’s probibalistic output","code":""},{"path":"/reference/trac.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform tree-based aggregation — trac","text":"list length num_w, list element corresponds solution choice w.  Note fraclist depends choice w. beta0 intercept; beta coefficient vector scale leaves tree; gamma coefficient vector nodes tree features sums logs leaf-features within node's subtree; alpha coefficient vector nodes tree features log geometric mean leaf-features within node's subtree.","code":""},{"path":"/reference/trac.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform tree-based aggregation — trac","text":"Regression: minimize_beta, beta0, gamma 1/(2n) || y - beta0 1_n - Z_clr beta ||^2 + lamda_max * frac || W * gamma ||_1 subject beta = gamma, 1_p^T beta = 0 W = diag(w) w_u > 0 u Classification: minimize_beta, beta0, gamma max(1 - y_i(beta0 + Z_clr_i * beta), 0)^2 + lambda_max * frac || W * gamma ||_1 subject beta = gamma, 1_p^T beta = 0 W = diag(w) w_u > 0 u Classification Huberized: see C2 formulation c-lasso Observe tuning parameter specified \"frac\", fraction lamda_max (smallest value gamma nonzero).","code":""},{"path":"/reference/transform_categorical_variables.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform non-compositional categorical input — transform_categorical_variables","title":"Transform non-compositional categorical input — transform_categorical_variables","text":"Transform factors numerical values 0 1","code":""},{"path":"/reference/transform_categorical_variables.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform non-compositional categorical input — transform_categorical_variables","text":"","code":"transform_categorical_variables(X, categorical)"},{"path":"/reference/transform_categorical_variables.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform non-compositional categorical input — transform_categorical_variables","text":"X see additional_covariates trac categorical vector indicating categorical ","code":""},{"path":"/reference/transform_categorical_variables.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform non-compositional categorical input — transform_categorical_variables","text":"data frame transformed categorical variables factor numerical","code":""}]
